#+STARTUP: overview
#+TITLE: ghetto's Emacs
#+CREATOR: ghetto
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;

* Theme
** Bigger font
#+BEGIN_SRC emacs-lisp
  (when (string-equal system-type "darwin")
    (set-face-attribute 'default nil
                        :height 150
                        :family "Inconsolata LGC"
                        ))
  (when (string-equal system-type "gnu/linux")
    (set-face-attribute 'default nil
                        :height 140
                        :family "Inconsolata"
                        ))
#+END_SRC
** A nice theme
#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme
    :ensure t
    :init
    (load-theme 'zenburn t))

  (set-face-attribute 'region nil :background "navy")
  (custom-set-faces
   '(line-number-current-line ((t :weight bold :foreground "CadetBlue2" :background "gray22")))
   '(show-paren-match ((t (:background "PeachPuff2" :foreground "gray13" :weight bold))))
   '(hl-line ((t (:background "gray22"))))
   )
#+END_SRC

* Basic Interface Settings
These are setting that do not depend on packages and are built-in enhancements to the UI.

** Frame size and position
#+BEGIN_SRC emacs-lisp
;;  (when window-system
;;    (add-to-list 'default-frame-alist '(height . 120))
;;    (add-to-list 'default-frame-alist '(width . 140))
;;    (set-frame-position (selected-frame) 1280 0))
#+END_SRC
** Looks
*** Remove lame startup screen
We use an actual replacement for it, keep reading or head directly to =dashboard=.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
*** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
;(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC
*** Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
;;(setq ring-bell-function 'ignore)
(setq visible-bell t)
#+END_SRC
*** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp 
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC
*** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
  
#+END_SRC
*** Pretty symbols
Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.
#+BEGIN_SRC emacs-lisp
  (defun ghetto/prettify-symbols ()
    "make some word or string show as pretty Unicode symbols"
    (setq prettify-symbols-alist
          '(
            ("lambda" . 955) ; λ
            ("->" . 8594)    ; →
            ("=>" . 8658)    ; ⇒
            ("phi" . ?φ)     ; φ
            ("sqrt" . ?√)    ; √
            ("<=" . ?≤)
            (">=" . ?≥)
            ("pi" . ?π)
            ("+-" . ?±)
            )))

  (add-hook 'prog-mode-hook 'ghetto/prettify-symbols)
  (when window-system (global-prettify-symbols-mode t))
#+END_SRC

** Functionality
*** Disable backups and auto-saves
I don't use either, you might want to turn those from =nil= to =t= if you do.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC

*** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Async
Lets us use asynchronous processes wherever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC

* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :config
      (setq projectile-completion-system 'helm)
      (setq projectile-mode-line '(:eval (format " Prj[%s]" (projectile-project-name))))
      :init
      (projectile-mode 1)
      ;(setq projectile-indexing-method 'native)
      ;(setq projectile-enable-caching t)
      (setq projectile-globally-ignored-files '("._*"))    
  )
#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

* Dashboard
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.
#+BEGIN_SRC emacs-lisp
  ;(use-package dashboard
  ;  :ensure t
  ;  :config
  ;  (dashboard-setup-startup-hook)
  ;  (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
  ;  (setq dashboard-items '((projects . 10)
  ;                          (bookmarks . 10)
  ;                          (recents  . 10)))
  ;  (setq dashboard-banner-logo-title "Welcome to ghettomacs"))
#+END_SRC
* Modeline
The modeline is the heart of emacs, it offers information at all times, it's persistent
and verbose enough to gain a full understanding of modes and states you are in.
One modeline-related setting that is missing and is instead placed at the bottom is =diminish=.
** Spaceline!
This enables spaceline, it looks better and works very well with my theme of choice.
#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
    (require 'spaceline-config)
      ;;(setq spaceline-buffer-encoding-abbrev-p nil)
      ;;(setq spaceline-line-column-p nil)
      ;;(setq spaceline-line-p nil)
      (setq powerline-default-separator 'wave)
      (spaceline-spacemacs-theme))
#+END_SRC
** Cursor position
Show the current line and column for your cursor.
We are not going to have =relative-linum-mode= in every major mode, so this is useful.
#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC

** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %b %y")
#+END_SRC

*** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

*** Remove load average
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average nil)
  (setq display-time-load-average nil)
#+END_SRC
** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance
with power-hungry processes in ansi-term

#+BEGIN_SRC emacs-lisp
  (use-package symon
    :ensure t
    :bind
    ("C-c s" . symon-mode))
#+END_SRC

** Highlight modified buffers
#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (lexical-let ((default-color (cons
                                 (face-background 'mode-line)
                                 (face-foreground 'mode-line))))
     (add-hook 'post-command-hook
               (lambda ()
                 (let ((color (cond ((minibufferp) default-color)
                                    (buffer-read-only default-color)
                                    ((buffer-modified-p)   '("#e80000" . "#ffffff"))
                                    (t default-color))))
                   (set-face-background 'mode-line (car color))
                   (set-face-foreground 'mode-line (cdr color))))))
  (buffer-modified-p)

#+END_SRC
* The terminal
** Default shell should be zsh
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/zsh")
  (defadvice ansi-term (before force-zsh)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

** Easy to remember keybinding
#+BEGIN_SRC emacs-lisp
  ;;(global-set-key (kbd "<C-s-return>") 'ansi-term)
  (global-set-key (kbd "<C-s-return>") 'eshell)
#+END_SRC

* Moving around emacs
One of the most important things about a text editor is how efficient you manage
to be when using it, how much time do basic tasks take you and so on and so forth.
One of those tasks is moving around files and buffers, whatever you may use emacs for
you /will/ be jumping around buffers like it's serious business, the following
set of enhancements aims to make it easier.

As a great emacs user once said:

#+BEGIN_QUOTE
Do me the favor, do me the biggest favor, matter of fact do yourself the biggest favor and integrate those into your workflow.
#+END_QUOTE

** a prerequisite for others packages
#+BEGIN_SRC emacs-lisp
;;  (use-package ivy
;;   :ensure t)
#+END_SRC

** scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** which-key and why I love emacs
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode)
    :diminish which-key-mode)
#+END_SRC

** windows,panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware
you probably use more than 2 panes/windows at times, cycling through all of them with
=C-x o= is annoying to say the least, it's a lot of keystrokes and takes time, time you could spend doing something more productive.

*** Use windmove to move between windows
#+BEGIN_SRC emacs-lisp
  ;; use command key on Mac
  (setq wmmodifiers '(meta super))
  (global-set-key (vector (append wmmodifiers '(left)))  'windmove-left)
  (global-set-key (vector (append wmmodifiers '(right))) 'windmove-right)
  (global-set-key (vector (append wmmodifiers '(up)))    'windmove-up)
  (global-set-key (vector (append wmmodifiers '(down))) 'windmove-down)
  ;; wrap around at edges
  (setq windmove-wrap-around t)
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun ghetto/split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'ghetto/split-and-follow-horizontally)

  (defun ghetto/split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'ghetto/split-and-follow-vertically)
#+END_SRC

*** Rebind keys for windows resize
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "C-s-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "C-s-<down>") 'shrink-window)
  (global-set-key (kbd "C-s-<up>") 'enlarge-window)
#+END_SRC
** winner mode
#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC
** buffers and why I hate list-buffers
Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.

*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
GHETTO UPGRADE: emacs already have a function for this: kill-this-buffer
#+BEGIN_SRC emacs-lisp
;;  (defun kill-current-buffer ()
;;    "Kills the current buffer."
;;    (interactive)
;;    (kill-buffer (current-buffer)))
;;  (global-set-key (kbd "C-x k") 'kill-current-buffer)

(global-set-key (kbd "C-x k") 'kill-this-buffer)

#+END_SRC

*** TODO Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
;;(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
I don't understand how ibuffer isn't the default option by now.
It's vastly superior in terms of ergonomics and functionality, you can delete buffers, rename buffer, move buffers, organize buffers etc.
GHETTO MODIFICATION: bind to C-x C-b instead of C-x b
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

**** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
(setq ibuffer-expert t)
#+END_SRC
**** grouping
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-projectile
    :ensure t
    :config

    (defun ghetto/ibuffer-set-filter-groups ()
      (interactive)
      (setq ibuffer-filter-groups 
            (append
             (ibuffer-projectile-generate-filter-groups)
             (list
              '("emacs" (or (name . "^\\*scratch\\*$")
                            (name . "^\\*Messages\\*$")
                            (name . "^\\*Dashboard\\*$")))
              '("dired" (mode . dired-mode))

              '("Org" (mode . org-mode))
              '("repl" (name . ".*REPL*")))
             ))

      (let ((ibuf (get-buffer "*Ibuffer*")))
        (when ibuf
          (with-current-buffer ibuf
            (pop-to-buffer ibuf)
            (ibuffer-update nil t)))))

    (add-hook 'ibuffer-hook
              (lambda ()
                (ghetto/ibuffer-set-filter-groups)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))

    (setq ibuffer-show-empty-filter-groups nil))

#+END_SRC

** line numbers and programming
#+BEGIN_SRC emacs-lisp
  ;;(add-hook 'prog-mode-hook 'ghetto/activate-line-numbers)

  (add-hook 'prog-mode-hook '(lambda ()
                               (setq-local display-line-numbers 'visual)
                               (line-number-mode t)))

  ;;(defun ghetto/activate-line-numbers ()
  ;;  (setq-local display-line-numbers 'visual)
  ;;  (line-number-mode t))
#+END_SRC

** DONE helm
CLOSED: [2018-05-18 Fri 18:42]
*** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind
    ("C-x C-f" . 'helm-find-files)
    ("C-x b" . 'helm-buffers-list)
    ("M-x" . 'helm-M-x)
    ("C-c C-f" . 'helm-recentf)
    ;("C-c p G" . 'helm-projectile-grep)
    :config
    (setq
     helm-M-x-fuzzy-match t
     helm-buffers-fuzzy-matching t
     helm-recentf-fuzzy-match t
     helm-semantic-fuzzy-match t
     helm-imenu-fuzzy-match t
     helm-split-window-inside-p t
     )
    ;(define-key helm-find-files-map (kbd "<tab>") 'helm-execute-persistent-action)
    ;(define-key helm-find-files-map (kbd "C-<backspace>") 'helm-find-files-up-one-level)

    :init
    (helm-mode 1)
    :diminish helm-mode)

  (require 'helm-config)    
  (helm-autoresize-mode 1)

  (use-package helm-swoop
    :ensure t
    :init (require 'helm-swoop))

  ;; Change the keybinds to whatever you like :)
  (global-set-key (kbd "C-s") 'helm-swoop)
  (global-set-key (kbd "M-i") 'helm-swoop-back-to-last-point)
  (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
  (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
  (global-set-key (kbd "C-M-y") 'helm-show-kill-ring)

  ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
  (setq helm-swoop-split-direction 'split-window-vertically)
  (setq helm-swoop-split-with-multiple-windows t)
  ;;(setq helm-swoop-use-fuzzy-match t)

  (use-package helm-projectile
    :ensure t)
  (helm-projectile-on)

  (use-package helm-ag
    :ensure t)
#+END_SRC

** avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("C-;" . avy-goto-char)
    ("C-M-;" . avy-goto-line)
    )

#+END_SRC
** Purpose
#+BEGIN_SRC emacs-lisp
  (use-package window-purpose
    :ensure t
    :bind
    ("C-c , l" . 'purpose-load-window-layout)
    ("C-c , s" . 'purpose-save-window-layout)
    :config
    (add-to-list 'purpose-user-mode-purposes '(prog-mode . source))
    (add-to-list 'purpose-user-mode-purposes '(pdf-view-mode . pdf))
    (add-to-list 'purpose-user-mode-purposes '(geiser-debug-mode . dbg))
    (add-to-list 'purpose-user-regexp-purposes '(".*REPL*" . repl))
    (purpose-compile-user-configuration)
    (purpose-mode))
#+END_SRC
* Text manipulation
** Multiple cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind
    ("C-c m c" . mc/edit-lines) ;; Add cursors to selected region (multiple lines)
    ;; Add cursors by keyword (mark keyword and then use below)
    ("C->" . mc/mark-next-like-this)
    ("C-<" . mc/mark-previous-like-this)
    ("C-c C-<" . mc/mark-all-like-this))
  (require 'mc-hide-unmatched-lines-mode)
#+END_SRC
* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to speak.
This can be best achieved using a number of small extensions. While on their own they might not be particularly
impressive. Together they create a nice environment for you to work in.

** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'rainbow-mode)
    :diminish rainbow-mode)
#+END_SRC

** Show parens
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    :diminish rainbow-delimiters-mode)
#+END_SRC

** Expand region
A pretty simple package, takes your cursor and semantically expands the region, so words, sentences, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-alh")
  (setq dired-dwim-target t)
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/elisp"))
  (require 'dired-fixups)

  (use-package dired-collapse
    :ensure t)

  (use-package dired-hide-dotfiles
    :ensure t
    :config
    (defun my-dired-mode-hook ()
      "My `dired' mode hook."
      ;; To hide dot-files by default
      ;;(dired-hide-dotfiles-mode)
      ;; To toggle hiding
      (define-key dired-mode-map "." #'dired-hide-dotfiles-mode))
    (add-hook 'dired-mode-hook #'my-dired-mode-hook))


#+END_SRC
** Ranger
#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :ensure t)
#+END_SRC
* Programming
Minor, non-completion related settings and plugins for writing code.
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
      (use-package yasnippet-snippets
        :ensure t)
      (yas-reload-all))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** company mode
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0.5)
    (setq company-minimum-prefix-length 2)
    )

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous)
    ;;(define-key company-active-map (kbd "SPC") #'company-abort)
    )

  (use-package company-quickhelp
    :ensure t
    :config
    (company-quickhelp-mode)
    (setq company-quickhelp-delay 0.5))
#+END_SRC

** highlight indent guides
#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'column)
    (setq highlight-indent-guides-responsive 'top)
    (setq highlight-indent-guides-delay 0)
    )

#+END_SRC
** minimap
#+BEGIN_SRC emacs-lisp
  ;;(use-package minimap
  ;;  :ensure t
  ;;  :config
  ;;  (setq minimap-dedicated-window 1)
  ;;  (setq minimap-window-location 'right)
  ;;  (setq minimap-width-fraction 0.05)
  ;;  )
#+END_SRC
** plaformio
#+BEGIN_SRC emacs-lisp
  (use-package platformio-mode
    :ensure t
    :init (add-hook 'c++-mode-hook 'platformio-conditionally-enable)
    )
#+END_SRC
** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= for a while I decided to drop it
in favor of =company=, and it turns out to have been a great decision.

Each category also has additional settings.

*** TODO c/c++
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
      (flycheck-clang-analyzer-setup)
      (add-hook 'c++-mode-hook 'flycheck-mode)
      (add-hook 'c-mode-hook 'flycheck-mode)))
#+END_SRC

**** company
Requires libclang to be installed.
#+BEGIN_SRC emacs-lisp
      (with-eval-after-load 'company
        (add-hook 'c++-mode-hook 'company-mode)
        (add-hook 'c-mode-hook 'company-mode))

      (use-package company-c-headers
        :ensure t)

      (use-package company-irony
        :ensure t
        :config
        (setq-local company-backends '((company-c-headers
                                  company-dabbrev-code
                                  company-irony)))
        )

      (use-package irony
        :ensure t
        :config
        (add-hook 'c++-mode-hook 'irony-mode)
        (add-hook 'c-mode-hook 'irony-mode)
        (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

**** TODO helm+ggtags
;;#+BEGIN_SRC emacs-lisp
;;  (setq
;;   helm-gtags-ignore-case t
;;   helm-gtags-auto-update t
;;   helm-gtags-use-input-at-cursor t
;;   helm-gtags-pulse-at-cursor t
;;   helm-gtags-prefix-key "\C-cg"
;;   helm-gtags-suggested-key-mapping t
;;   )
;;
;;  (require 'helm-gtags)
;;  ;; Enable helm-gtags-mode
;;  (add-hook 'dired-mode-hook 'helm-gtags-mode)
;;  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
;;  (add-hook 'c-mode-hook 'helm-gtags-mode)
;;  (add-hook 'c++-mode-hook 'helm-gtags-mode)
;;  (add-hook 'asm-mode-hook 'helm-gtags-mode)
;;
;;  (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
;;  (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
;;  (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
;;  (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
;;  (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
;;  (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
;;#+END_SRC
*** python
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'elpy-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC
**** TODO company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

;;  (use-package company-jedi
;;    :ensure t
;;    :config
;;      (require 'company)
;;      (add-to-list 'company-backends 'company-jedi))
;;
;;  (defun python-mode-company-init ()
;;    (setq-local company-backends '((company-jedi
;;                                    company-etags
;;                                    company-dabbrev-code))))
;;
;;  (use-package company-jedi
;;    :ensure t
;;    :config
;;      (require 'company)
;;      (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

**** autopep8
#+BEGIN_SRC emacs-lisp
  (use-package py-autopep8
    :ensure t
    :config
    (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))

#+END_SRC
**** elpy
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.py$" . python-mode))
    :bind (:map elpy-mode-map
                ("M-." . elpy-goto-definition)
                ("M-," . pop-tag-mark))
    :config
    (setq elpy-rpc-backend "jedi"))

  (use-package python
    :mode ("\\.py" . python-mode)
    :config
    (require 'elpy)
    (setq python-indent-offset 4)
    (elpy-enable))
#+END_SRC
**** pyenv
#+BEGIN_SRC emacs-lisp
  (use-package pyenv-mode
    :ensure t
    :init
    (add-to-list 'exec-path "~/.pyenv/shims")
    (setenv "WORKON_HOME" "~/.pyenv/versions/")
    :config
    (pyenv-mode)
    :bind
    ("C-c v a" . pyenv-activate-current-project))

  (defun pyenv-activate-current-project ()
    "Automatically activates pyenv version if .python-version file exists."
    (interactive)
    (let ((python-version-directory (locate-dominating-file (buffer-file-name) ".python-version")))
      (if python-version-directory
          (let* ((pyenv-version-path (f-expand ".python-version" python-version-directory))
                 (pyenv-current-version (s-trim (f-read-text pyenv-version-path 'utf-8))))
            (pyenv-mode-set pyenv-current-version)
            (message (concat "Setting virtualenv to " pyenv-current-version))))))

  (defvar pyenv-current-version nil nil)

  (defun pyenv-init()
    "Initialize pyenv's current version to the global one."
    (let ((global-pyenv (replace-regexp-in-string "\n" "" (shell-command-to-string "pyenv global"))))
      (message (concat "Setting pyenv version to " global-pyenv))
      (pyenv-mode-set global-pyenv)
      (setq pyenv-current-version global-pyenv)))

  (add-hook 'after-init-hook 'pyenv-init)
  ;;(add-hook 'python-mode-hook 'pyenv-activate-current-project)
#+END_SRC

*** emacs-lisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC
*** DONE bash
CLOSED: [2018-05-18 Fri 20:46]
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'flycheck-mode)

#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'company-mode)
  
  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
    (require 'company)
    (add-hook 'sh-mode-hook 'shell-mode-company-init))
#+END_SRC

*** Scheme
**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'company-mode)
#+END_SRC
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'scheme-mode-hook 'yas-minor-mode)
#+END_SRC
**** Geiser
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :ensure t
    :config
    (setq geiser-chez-binary "chez")
    (setq geiser-guile-binary "guile")
    (setq geiser-guile-jump-on-debug-p t)
    (setq geiser-repl-use-other-window nil)
    (add-to-list 'company-backends 'geiser-company)
    (add-hook 'geiser-mode-hook
              (lambda ()
                (company-quickhelp-mode -1)
                (company-quickhelp-local-mode -1))))

#+END_SRC
**** Paredit
#+BEGIN_SRC emacs-lisp 
  (use-package paredit
    :ensure t
    :config
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    (add-hook 'geiser-repl-mode-hook      #'enable-paredit-mode))
#+END_SRC

* Git integration
Countless are the times where I opened ansi-term to use =git= on something.
These times are also something that I'd prefer stay in the past, since =magit= is
great. It's easy and intuitive to use, shows its options at a keypress and much more.
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+END_SRC

* Remote editing
+I have no need to directly edit files over SSH, but+ what I do need is a way to edit files as root.
Opening up nano in a terminal as root to play around with grubs default settings is a no-no, this solves that.
** Tramp
#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh")

#+END_SRC
** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind
      ("C-x M-f" . sudo-edit))
#+END_SRC
* Org
One of the absolute greatest features of emacs is called "org-mode".
This very file has been written in org-mode, a lot of other configurations are written in org-mode, same goes for
academic papers, presentations, schedules, blogposts and guides.
Org-mode is one of the most complex things ever, lets make it a bit more usable with some basic configuration.


Those are all rather self-explanatory.

** Common settings

#+BEGIN_SRC emacs-lisp
  (setq org-ellipsis " ")
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (setq org-log-done t)
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
	    '(lambda ()
	       (visual-line-mode 1)))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
  ;;(global-set-key (kbd "C-c '") 'org-edit-src-code)
  ;;(global-set-key "\C-cl") 'org-store-link)
  ;;(global-set-key "\C-ca") 'org-agenda)
  ;;(global-set-key "\C-cc") 'org-capture)
  ;;(global-set-key "\C-cb") 'org-switchb)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!

*** latex
#+BEGIN_SRC emacs-lisp
  (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
    (require 'xdvi-search))
#+END_SRC
*** Twitter Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure t)
#+END_SRC

* Diminishing modes
Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config,
you might end up with a lot of clutter there, the package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

*THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN*

Edit this list as you see fit!
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'visual-line-mode)
    (diminish 'geiser-autodoc-mode)
    )
#+END_SRC

* Keyboard
** Use left alt as meta keys and right alt as key modifier
Not necessary with US layout
#+BEGIN_SRC emacs-lisp
;;  (setq ns-alternate-modifier 'meta)
;;  (setq ns-right-alternate-modifier 'none)
#+END_SRC
* Environment
** Exec PATH
#+BEGIN_SRC emacs-lisp
  ;;  (when (string-equal system-type "darwin")
  ;;    (let (
  ;;          (mypaths
  ;;           '(
  ;;             "/Users/ghetto/.pyenv/shims"
  ;;             "/usr/local/bin"
  ;;             "/usr/bin"
  ;;             "/bin"
  ;;
  ;;             "/sbin"
  ;;             "/usr/local/MacGPG2/bin"
  ;;             "/usr/local/share/dotnet"
  ;;             "/opt/X11/bin"
  ;;             "/Library/Frameworks/Mono.framework/Versions/Current/Commands"
  ;;             ))
  ;;          )
  ;;      (setenv "PATH" (concat (mapconcat 'identity mypaths ";") (getenv "PATH")))
  ;;      (setq exec-path (append mypaths (list "." exec-directory)))))

  (use-package exec-path-from-shell
    :ensure t
    :init
    (exec-path-from-shell-initialize))
#+END_SRC
** auth-sources
#+BEGIN_SRC emacs-lisp
  (setq auth-sources
        '((:source "~/.emacs.d/secrets/.authinfo.gpg")))
#+END_SRC
* EVIL
#+BEGIN_SRC emacs-lisp
;;  (use-package evil
;;    :ensure t
;;    :init
;;    (evil-mode 0)
;;    :config
;;    (setq evil-search-module 'evil-search)
;;    )
;;
;;  (lexical-let ((default-color (cons (face-background 'mode-line)
;;                                     (face-foreground 'mode-line))))
;;    (add-hook 'post-command-hook
;;              (lambda ()
;;                (let ((color (cond ((minibufferp) default-color)
;;                                   ((evil-insert-state-p) '("#e80000" . "#ffffff"))
;;                                   ((evil-emacs-state-p)  '("#444488" . "#ffffff"))
;;                                   ((buffer-modified-p)   '("#006fa0" . "#ffffff"))
;;                                   (t default-color))))
;;                  (set-face-background 'mode-line (car color))
;;                  (set-face-foreground 'mode-line (cdr color))))))
;;
;;  (use-package evil-paredit
;;    :ensure t
;;    :config
;;    (add-hook 'emacs-lisp-mode-hook 'evil-paredit-mode)
;;    (add-hook 'eval-expression-minibuffer-setup-hook 'evil-paredit-mode)
;;    (add-hook 'ielm-mode-hook             'evil-paredit-mode)
;;    (add-hook 'lisp-mode-hook             'evil-paredit-mode)
;;    (add-hook 'lisp-interaction-mode-hook 'evil-paredit-mode)
;;    (add-hook 'scheme-mode-hook           'evil-paredit-mode)
;;    (add-hook 'geiser-repl-mode-hook      'evil-paredit-mode)
;;    )
;;
;;  (use-package undo-tree
;;    :diminish undo-tree-mode)
#+END_SRC

* PDF tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (pdf-tools-install))
#+END_SRC

